#include "Buffer.hpp"

Buffer::Buffer(Context& context, uint32_t size, vk::BufferUsageFlags usage, vk::MemoryPropertyFlags properties) :
    context(&context), size(size)
{
	create(usage, size);
	allocate(properties);
	bind();
}

Buffer::~Buffer()
{
	if (memory)
		context->getLogicalDevice().freeMemory(memory);

	if (buffer)
		context->getLogicalDevice().destroyBuffer(buffer);
}

void Buffer::create(vk::BufferUsageFlags usage, size_t size)
{
	vk::BufferCreateInfo create_info{};
	create_info.setSize(size)
	    .setUsage(usage)
	    .setSharingMode(vk::SharingMode::eExclusive);

	buffer = context->getLogicalDevice().createBuffer(create_info);
}

void Buffer::allocate(vk::MemoryPropertyFlags properties)
{
	MemoryInfo info = queryMemoryInfo(properties);

	vk::MemoryAllocateInfo allocate_info{};
	allocate_info.setAllocationSize(info.size)
	    .setMemoryTypeIndex(info.index);

	memory = context->getLogicalDevice().allocateMemory(allocate_info);
}

void Buffer::bind(size_t bind_offset)
{
	context->getLogicalDevice().bindBufferMemory(buffer, memory, bind_offset);
}

void Buffer::map(size_t map_size, size_t map_offset)
{
	data = context->getLogicalDevice().mapMemory(memory, map_offset, map_size);
}

void Buffer::unmap()
{
	if (data) {
		context->getLogicalDevice().unmapMemory(memory);
		data = nullptr;
	}
}

void Buffer::copyTo(vk::Buffer dst, size_t size, size_t src_offset, size_t dst_offset)
{
	context->execute([&](vk::CommandBuffer command) {
		vk::BufferCopy copy_region{};
		copy_region.setSrcOffset(src_offset)
		    .setDstOffset(dst_offset)
		    .setSize(size);

		command.copyBuffer(buffer, dst, copy_region);
	});
}

void Buffer::copyFrom(vk::Buffer src, size_t size, size_t src_offset, size_t dst_offset)
{
	context->execute([&](vk::CommandBuffer command) {
		vk::BufferCopy copy_region{};
		copy_region.setSrcOffset(src_offset)
		    .setDstOffset(dst_offset)
		    .setSize(size);

		command.copyBuffer(src, buffer, copy_region);
	});
}

void Buffer::upload(const void* src, size_t src_size, size_t dst_offset)
{
	map(src_size, dst_offset);
	std::memcpy(data, src, src_size);
	unmap();
}

std::unique_ptr<Buffer> Buffer::createFrom(Context& context, vk::BufferUsageFlags Usage, const void* src, size_t size)
{
	if (!src || size == 0)
		return nullptr;

	auto host_buffer = std::make_unique<Buffer>(context, size,
	                                            vk::BufferUsageFlagBits::eTransferSrc,
	                                            vk::MemoryPropertyFlagBits::eHostVisible | vk::MemoryPropertyFlagBits::eHostCoherent);
	host_buffer->upload(src, size);

	auto device_buffer = std::make_unique<Buffer>(context, size,
	                                              Usage | vk::BufferUsageFlagBits::eTransferDst,
	                                              vk::MemoryPropertyFlagBits::eDeviceLocal);
	device_buffer->copyFrom(host_buffer->get(), size);

	return device_buffer;
}

vk::Buffer Buffer::get() const
{
	return buffer;
}

vk::DeviceSize Buffer::getSize() const
{
	return size;
}

MemoryInfo Buffer::queryMemoryInfo(vk::MemoryPropertyFlags prop_flags) const
{
	MemoryInfo info{};

	auto requirements = context->getLogicalDevice().getBufferMemoryRequirements(buffer);
	info.size = requirements.size;

	auto properties = context->getPhysicalDevice().getMemoryProperties();
	for (auto i = 0; i < properties.memoryTypeCount; i++)
		if (requirements.memoryTypeBits & (1 << i) && (properties.memoryTypes[i].propertyFlags & prop_flags)) {
			info.index = i;
			break;
		}

	return info;
}
